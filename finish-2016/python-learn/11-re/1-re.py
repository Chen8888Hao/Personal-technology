# '00\d'可以匹配'007'，但无法匹配'00A'
# '\d\d\d'可以匹配'010'
# '\w\w\d'可以匹配'py3'
# . 可以匹配任何字符
# 'py.'可以匹配'pyc'、'pyo'、'py!'等等

# 要匹配变长的字符，在正则表达式中，用*表示任意个字符（包括0个），用+表示至少一个字符，用?表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符

# \d{3}\s+\d{3,8}
# \d{3} 匹配三个数字 例如 '010'
# \s    匹配一个空格，包括（TAB等空白符）， +  至少匹配一个空格 '  '
# \d{3,8} 匹配 3 - 8 个数字

# 匹配 \d{3}\-\d{3,8}  010-12345

# 仍然无法匹配'010 - 12345'，因为带有空格。所以我们需要更复杂的匹配方式

#
# 进阶
#

# [0-9a-zA-Z\_] 数字 字母 下横线
# [0-9a-zA-Z\_]+ 匹配至少由一个数字、字母、下横线组成的字符串
# [a-zA-Z\_][0-9a-zA-Z\_]* 字母或者下横线开头，后面任意字母，数字和下横线，就是Python合法的变量
# [a-zA-Z\_][0-9a-zA-Z\_]{0, 19} 长度1-20的字符

# A|B A或者B [P|p]ython 可以匹配 'Python' 'python'
# ^ 行的开头 ^\d 必须数字开头
# $ 行的结束 \d$ 必须数字结尾
# py 也可以匹配到 python，加上 ^py$ 只能匹配 py

s = 'ABC\\-001'  
# 'ADC\-001'

# 所以 我们可以用内置的,不考虑转义 

s = r'ABC\-001'

import re

print(re.match(r'^\d{3}\-\d{3,8}$','010-12345'))
print(re.match(r'^\d{3}\-\d{3,8}$','010 12345'))


test = '用户输入字符串'
if re.match(r'正则表达式',test):
    print('ok')
else:
    print('failed')


print('a b    c'.split(' '))

print(re.split(r'\s+','a b    c    cc'))

print(re.split(r'[\s\,\:]+','a,b,c:  d'))
# \s 是空格

# 用()表示的就是要提取的分组（Group）

m = re.match(r'^(\d{3})-(\d{3,8})$','010-12345')
print(m)

print(m.group(0))
print(m.group(1))
print(m.group(2))


# 贪婪匹配
# 最后需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0

print(re.match(r'^(\d+)(0*)$','102300').groups())
print(re.match(r'^(\d+?)(0*)$','102300').groups())

# 由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。

# 必须让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\d+采用非贪婪匹配：

re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')

print(re_telephone.match('010-12345').groups())
print(re_telephone.match('010-8086').groups())
