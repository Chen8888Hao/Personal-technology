# 深入列表

* list.append(x)
	* 在列表的尾部添加一个项 等价于 a[len(a):] = [x]

* list.extend(L)
	* 用给入的列表讲当前列表接长 等价于 a[len(a):] = L

* list.insert(i, x)
	* 在给定的位置上插入项。第一个参数就是准备在它之前插入的元素的索引。所以 a.insert(0, x) 会在列表头部插入，a.insert(len(a), x) 等价于 a.append(x)

* list.remove(x)
	* 移除列表中第一个值为 x 的项，没有符合要求的时候，产生一个错误

* list.pop([i])
	* 删除列表给定位置的项，并返回它。如果没有制定索引， a.pop 移除返回列表最后一项。函式原型的 i 在中方括号中意为它是一个可选参数，而不是你应该键入一个方括号
	
* list.index(x)
	* 返回列表中第一个值为 x 的索引项，如果没有匹配的，产生错误

* list.count(x)
	* 返回列表中 x 出现的次数

* list.sort()
	* 就地完成列表排序

* list.reverse()
	* 就地完成项目的翻转

下面这个示例演示了列表的大部分方法:

```
>>> a = [66.25, 333, 333, 1, 1234.5]
>>> print(a.count(333), a.count(66.25), a.count('x'))
2 1 0
>>> a.insert(2, -1)
>>> a.append(333)
>>> a
[66.25, 333, -1, 333, 1, 1234.5, 333]
>>> a.index(333)
1
>>> a.remove(333)
>>> a
[66.25, -1, 333, 1, 1234.5, 333]
>>> a.reverse()
>>> a
[333, 1234.5, 1, 333, -1, 66.25]
>>> a.sort()
>>> a
[-1, 1, 66.25, 333, 333, 1234.5]   
```

## 把列表当作堆栈用

列表的方法使得其能十分简便的当成堆栈来使用, 堆栈的特性是最后添加的元素就是第一个取出的元素 (即”后入先出”). 要在栈顶添加一个项, 就使用 append(). 要从栈顶取回一个项, 就使用不带显式索引的 pop(). 例如:

```
>>> stack = [3, 4, 5]
>>> stack.append(6)
>>> stack.append(7)
>>> stack
[3, 4, 5, 6, 7]
>>> stack.pop()
7
>>> stack
[3, 4, 5, 6]
>>> stack.pop()
6
>>> stack.pop()
5
>>> stack
[3, 4]
```

## 队列

也可以把列表当成队列使用, 队列的特性是第一个添加的元素就是第一个取回的元素 (即”先入先出”); 然而, 这时列表是低效的. 从列表的尾部添加和弹出是很快的, 而在列表的开头插入或弹出是慢的 (因为所有元素都得移动一个位置).

要实现一个队列, 使用 collection.deque, 它被设计成在两端添加和弹出都很快. 例如:

```
>>> from collections import deque
>>> queue = deque(["Eric", "John", "Michael"])
>>> queue.append("Terry")           # Terry 进入
>>> queue.append("Graham")          # Graham 进入
>>> queue.popleft()                 # 第一个进入的现在离开
'Eric'
>>> queue.popleft()                 # 第二个进入的现在离开
'John'
>>> queue                           # 剩余的队列, 它按照进入的顺序排列
deque(['Michael', 'Terry', 'Graham'])
```

## 列表推导式

列表推导式提供了从序列中创建列表的简便途径. 通常程序会对序列的每一个元素做些操作,并以其结果作为新列表的元素, 或者根据指定的条件来创建子序列.

而列表推导式的结构是, 在一个方括号里, 首先是一个表达式, 随后是一个 for 子句, 然后是零个或更多的 for 或 if 子句. 结果将是通过计算 for 和 if 子句来获得的一个列表. 如果要使表达式推导式出元组, 就必须用圆括号.

这里我们将一个数字列表每个元素翻三倍从而生成一个新列表:

```
>>> vec = [2, 4, 6]
>>> [3*x for x in vec]
[6, 12, 18]
```

现在加点儿小花样:

```
>>> [[x, x**2] for x in vec]
[[2, 4], [4, 16], [6, 36]]
```

这里我们对序列里每一项逐个调用某方法:

```
>>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']
>>> [weapon.strip() for weapon in freshfruit]
['banana', 'loganberry', 'passion fruit']
```

我们可以用 if 子句来进行过滤:

```
>>> [3*x for x in vec if x > 3]
[12, 18]
>>> [3*x for x in vec if x < 2]
[]
```

元组经常能不用圆括号而创建, 但这里不行:

```
>>> [x, x**2 for x in vec]  # error - parens required for tuples
  File "<stdin>", line 1, in ?
    [x, x**2 for x in vec]
               ^
SyntaxError: invalid syntax
>>> [(x, x**2) for x in vec]
[(2, 4), (4, 16), (6, 36)]
```

这里是一些循环的嵌套和其它技巧的演示:

```
>>> vec1 = [2, 4, 6]
>>> vec2 = [4, 3, -9]
>>> [x*y for x in vec1 for y in vec2]
[8, 6, -18, 16, 12, -36, 24, 18, -54]
>>> [x+y for x in vec1 for y in vec2]
[6, 5, -7, 8, 7, -5, 10, 9, -3]
>>> [vec1[i]*vec2[i] for i in range(len(vec1))]
[8, 12, -54]
```

列表推导式可使用复杂的表达式和嵌套的函式:

```
>>> [str(round(355/113, i)) for i in range(1, 6)]
['3.1', '3.14', '3.142', '3.1416', '3.14159']
```

## 嵌套列表推导式

如果你受的了的话, 其实列表推导式是可以嵌套的. 它的确是个强大的工具, 但 – 就像所有强大的工具一样 – 需要被小心地使用,

考虑下面的例子, 有一个 3x3 的矩阵, 存储为一个包含三个列表的列表, 每一行一个列表:

```
>>> mat = [
...        [1, 2, 3],
...        [4, 5, 6],
...        [7, 8, 9],
...       ]
```

现在, 如果你想交换行和列, 可以使用列表推导式:

```
>>> print([[row[i] for row in mat] for i in [0, 1, 2]])
[[1, 4, 7], [2, 5, 8], [3, 6, 9]]
```

使用*嵌套*列表推导式时特别需要注意:

从右至左地阅读嵌套列表推导式更容易理解.

该代码的冗长版本, 就明白地表述了流程:

```
for i in [0, 1, 2]:
    for row in mat:
        print(row[i], end="")
    print()
```

现实中, 你应当选择内建函式来处理复杂流程. 这里, 函式 zip() 就非常好用.

```
>>> list(zip(*mat))
[(1, 4, 7), (2, 5, 8), (3, 6, 9)]
```

# 元组合序列
